# wmllint: no translatables

# This file explains the concept, contains helper code and more.
# The actual ai code has been moved into ai.lua file.

#define IF_AI_CONTROLLED
[filter_condition]
[lua]
name="controllercheck"
code = <<
return wesnoth.sync.evaluate_single(
	function()
		return { value = false }
	end,
	function()
		return { value = true }
	end).value
>>
[/lua]
[/filter_condition]
#enddef


#define CE_AI_EVENT


## first is not spwan units in village where is 0 enemies in range
## turn water units into ships???
## cycle through other villages to recruit rest of money
## strongest unit to stay inside village on recruit
## recruited units to have attacks left..


## spawns happen not on village but near village somehow..
## spawns happen on water somehow..
## stupid full surround of 3g spawns when can have few 10g units
## spare money need to go in some random villa..
## first turn gives some bug with empty unstore 

## start with tracing message of how much money AI has in begin of turn
## how much he spends on units and how much is left in end of turn


######################################################
# Events to handle the [option]s to give the AI a bonus.

[event]
name=start
# Done in start so that the change is visible with alt+s.
# Done after the event form prestart which backs up the initial income.
[lua]
name="initial ai bonus gold"
code = <<
local ai_extra_gold = wml.variables['CE_SYSTEM.Experimental_AI_Extra_Gold_start'] or 0
local ai_extra_income = wml.variables['CE_SYSTEM.Experimental_AI_Extra_Gold_perturn'] or 0
local ai_village_bonus = wml.variables['CE_SYSTEM.Experimental_AI_Extra_Village_Gold']

if ai_extra_gold ~= 0 or ai_extra_income ~= 0 or ai_village_bonus then

	local c = wesnoth.sync.evaluate_single(
		function()
			local r = {}
			for i,s in ipairs(wesnoth.sides) do
				r['side'..i]=s.controller
			end
			return r
		end )

	for i,s in ipairs(wesnoth.sides) do
		if c['side'..i] == 'ai' then

			s.gold = s.gold + ai_extra_gold
			s.base_income = s.base_income + ai_extra_income
			if ai_village_bonus then
				s.village_gold = (wesnoth.sides[s.side].variables.initial_village_gold or 1) + 1
			end

		end
	end

end
>>
[/lua]
[/event]

########################################################

[event]
name=side turn
first_time_only=no
# Normally multiplayer maps have +2 village gold, in Conquest they have +1 for the village and +1 from workers and slighlty more than +1 from regions.
# There is no need to try to make the ai recruit workers and the ai will also be not as good as players with expanding.
# Instead of workers, increase village gold.
# Checking this every side turn in case a side was set to AI after a player left, or given to a player just before.
[lua]
name="ai worker gold"
code=<<
if wml.variables['CE_SYSTEM.Experimental_AI_Extra_Village_Gold'] then
	local p = wesnoth.sync.evaluate_single( function() return { controller = wesnoth.sides[wesnoth.current.side].controller } end )

	if p.controller == 'ai' then
		-- Village Gold should be 2
		wesnoth.sides[wesnoth.current.side].village_gold = (wesnoth.sides[wesnoth.current.side].variables.initial_village_gold or 1) + 1
	else
		-- Village Gold should be 1
		wesnoth.sides[wesnoth.current.side].village_gold = wesnoth.sides[wesnoth.current.side].variables.initial_village_gold or 1
	end
end

-- We currently don't save whether the side was before receiving the ai income bonus, thus recalculate income.
if (wml.variables['CE_SYSTEM.Experimental_AI_Extra_Gold_perturn'] or 0) ~= 0 and wesnoth.current.turn > 1 then
	calculate_region_bonus(wesnoth.current.side)
	create_total_bonus_message()
end
>>
[/lua]
[/event]

######################################################
# MAIN AI CODE IS INCLUDED HERE

[event]
	name=preload
	first_time_only=no
	[lua]
		name="move_unit.lua"
		code={~add-ons/Conquest_Asterisk/lua/move_unit.lua}
	[/lua]
	[lua]
		name="ai.lua"
		code={~add-ons/Conquest_Asterisk/lua/ai.lua}
	[/lua]
[/event]

[event]
	# name=turn refresh
	name=side turn end
	first_time_only=no
	{IF_AI_CONTROLLED}

	# This could be in a moveto event, but for now they happen at turn end before recruitment.
	{UNLOAD_UNITS_FROM_BOATS}

	# Recruit units and co.
	[lua]
		name="ai stuff"
		code="main_ai_code()"
	[/lua]
[/event]

########## ANY AI

## if controller side is AI then

## for each current side village

## check if any enemies around village (visible)

## count total number of enemies

## for each enemy count how many of them can reach specific village

## calculate total power (gold) of all enemies that can reach this village

###### STUPID AI

## save result and go to next village of current side

## check how much gold you have against total enemies power in gold equivalent

## if you have less gold than enemies power then use loop 1

#### LOOP 1

## do same as before for each village but now count the amount of enemy units

## if you have more gold than 1g units needed to protect then start recruiting them
## and use leftover money to create powerful units to capture something

## else see which villages would decrease your bonus if lost
## and for each important village do LOOP 1 again

#### / LOOP 1

####### / stupid ai

########## MOST SMART AI

## count total number of your own units

## for each unit of your side count how many of them can reach that village

## calculate total power (gold) of all own units that can reach this village

## minus your units with enemy units, count difference

## save result and go to next village of current side

## check how much gold you have against total enemies power difference in gold equivalent

## check if you need expensive units or you can protect yourself with cheap ones

########## / MOST SMART AI

########### MICRO AI #########
[event]
	name=side turn 1
	first_time_only=no

	[micro_ai]
		side=$side_number
		ai_type=goto
		action=add
		ca_id=ce_capture_empty_village_$side_number  ## capture empty villages
		[filter]
			canrecruit=no
			[not]
				ability_type=works
			[/not]
			# Empty village of other side nearby.
			[and]
				[filter_location]
					terrain=*^V*
					[filter_owner]
						[enemy_of]
							side=$side_number
						[/enemy_of]
					[/filter_owner]
					[not]
						[filter][/filter]
					[/not]
					radius=10
				[/filter_location]
				[or]
					[filter_location]
						terrain=*^V*
						owner_side=0
						[not]
							[filter][/filter]
						[/not]
						radius=10
					[/filter_location]
				[/or]
			[/and]
		[/filter]

		# Go to these places.
		[filter_location]
			terrain=*^V*
			[filter_owner]
				[enemy_of]
					side=$side_number
				[/enemy_of]
			[/filter_owner]
			[not]
				[filter][/filter]
			[/not]
			[and]
				[filter]
					side=$side_number
				[/filter]
				radius=10
			[/and]
			[or]
				terrain=*^V*
				owner_side=0
				[not]
					[filter][/filter]
				[/not]
				[and]
					[filter]
						side=$side_number
					[/filter]
					radius=10
				[/and]
			[/or]
		[/filter_location]

		unique_goals=yes
		ca_score=210011
		ignore_enemy_at_goal=no
		ignore_units=no
	[/micro_ai]

[/event]
##############################
#enddef

#define UNLOAD_UNITS_FROM_BOATS
	# Store boats which are adjacent to exactly one empty village.
	# Regardless whether they have already a unit loaded or not.
	[store_unit]
		[filter]
			side=$side_number
			[filter_location]
				[filter_adjacent_location]
					gives_income=yes
					[not]
						# Has no unit on village.
						[filter][/filter]
					[/not]
					[not]
						owner_side=$side_number
					[/not]
					# First only the ones with one adjacent village.
					# They can only unload there, and should be handled first.
					count=1
				[/filter_adjacent_location]
			[/filter_location]
		[/filter]
		variable=ships_next_to_foreign_coast_village
	[/store_unit]

	# Boats adjacent to two empty villages.
	# They are appended to the array and will be cheecked after the previous ones.
	# If another boat has also been adjacent to one of the two villages, it will unload first.
	# The boats stored here will then unload to the other village.
	[store_unit]
		mode=append
		[filter]
			side=$side_number
			[filter_location]
				[filter_adjacent_location]
					gives_income=yes
					[not]
						[filter][/filter]
					[/not]
					[not]
						owner_side=$side_number
					[/not]
					# The remaining boats.
					count=2-6
				[/filter_adjacent_location]
			[/filter_location]
		[/filter]
		variable=ships_next_to_foreign_coast_village
	[/store_unit]

	[foreach]
		array=ships_next_to_foreign_coast_village
		variable=boat
		[do]
			# Check again, multiple ships might be adjacent to the village.
			# Migh have just unloaded a unit there.
			[store_locations]
				gives_income=yes
				[not]
					[filter][/filter]
				[/not]
				[not]
					owner_side=$side_number
				[/not]
				[filter_adjacent_location]
					x=$boat.x
					y=$boat.y
				[/filter_adjacent_location]
				variable=unboard_spot
			[/store_locations]

			# Only unload if no other boat unloaded here.
			[if]
				{VARIABLE_CONDITIONAL unboard_spot.length greater_than_equal_to 1}
				[then]

					# Unload or spawn?
					# Unload by AI can only happen if it was boarded by a player before.
					[if]
						{VARIABLE_CONDITIONAL boat.status.loaded boolean_equals yes}
						[then]
							# Mostly same code like when player disembarks, but not clearing same variables.
							[unstore_unit]
								variable=boat.variables.unit
								x=$unboard_spot.x
								y=$unboard_spot.y
							[/unstore_unit]
							[capture_village]
								x=$unboard_spot.x
								y=$unboard_spot.y
								side=$side_number
								fire_event=yes
							[/capture_village]
							{CLEAR_VARIABLE boat.status.loaded}
							{CLEAR_VARIABLE boat.variables.loaded} # unused
							{CLEAR_VARIABLE boat.variables.unit}
							[unstore_unit]
								variable=boat
							[/unstore_unit]
						[/then]

						# Spawn new unit if none is loaded.
						# AI never boards boats.
						# That code doesn't exist.
						# Instead we spawn a new unit here instead of unboarding.
						[else]
							[set_variables]
								name=ce_spawn
								[value]
									animate=no
									side=$side_number
									x=$unboard_spot.x
									y=$unboard_spot.y
								[/value]
							[/set_variables]
							[fire_event]
								name=ce_spawn_1g_militia
							[/fire_event]
							{CLEAR_VARIABLE ce_spawn}
							[gold]
								amount=-1
								side=$side_number
							[/gold]
						[/else]
					[/if]

				[/then]
			[/if]
			# This will clear shroud/fog after unboarding or spawning.
			[redraw]
				clear_shroud=yes
			[/redraw]
			{CLEAR_VARIABLE unboard_spot}
		[/do]
	[/foreach]
	{CLEAR_VARIABLE ships_next_to_foreign_coast_village}
#enddef

#define IDEA_TO_BOARD_BOATS_NOT_USED
[event]
name=turn refresh
first_time_only=no
{IF_AI_CONTROLLED}
[lua]
name="ai tries to board boats"
code = <<
function recruit_and_board_units_into_ships()
	-- local side_villages = wesnoth.map.find{ gives_income = true, owner_side = wesnoth.current.side, wml.tag['not'] { wml.tag.filter {} } }

	local empty_villages_with_adjacent_empty_ship = wesnoth.map.find{ gives_income = true, owner_side = wesnoth.current.side,
		wml.tag['not'] { wml.tag.filter {} },
		wml.tag.filter_adjacent_location {
			wml.tag.filter {
				side = wesnoth.current.side,
				race = 'ship',
				wml.tag['not'] {
					status = 'loaded'
				}
			}
		}
	}

	for f, loc in ipairs(empty_villages_with_adjacent_empty_ship) do
		for x, y in wesnoth.current.map:iter_adjacent(loc) do
			local u = wesnoth.units.get(x, y)
			if u:matches { race = 'mechanical,ship', wml.tag['not'] { status = 'loaded' } } then
				wesnoth.interface.add_chat_message('valid ship at '..x..','..y)
			end
		end
	end
	if #empty_villages_with_adjacent_empty_ship == 0 then
		wesnoth.interface.add_chat_message('No empty ships near empty villages.')
	end

	-- PROBLEM that village will never be empty where AI recruited.. so not sure how to solve that

	-- check all owner side empty villages for adjacent empty ships
	-- recruit 1g militia to board into ship, reduce gold by 1g
	-- board unit into ship action
	-- create turn end event where 1g unit unboards into empty enemy village and suicides if possible
end

-- recruit_and_board_units_into_ships()
-- wesnoth.interface.add_chat_message('AI side has '..wesnoth.sides[wesnoth.current.side].gold..' gold.')
>>
[/lua]
[/event]
#enddef

#define shzfhdkfhldkhffgdkh_unsuded_unused
[event]
name=turn 999
  [micro_ai]
            side=$side_number
            ai_type=goto
            action=add
            ca_id=ce_goto_enemy_village_$side_number   ## attack enemy villages
            [filter]
				[not]
				canrecruit=yes
				[/not]
				[not]
               ability=ce_worker,ce_build_new_city,ce_warship
				[/not]
				[filter_location]
				terrain=*^V*
				[filter_owner]
				[enemy_of]
				side=$side_number
				[/enemy_of]
				[/filter_owner]
				radius=4
				[and]
				[filter]
				[/filter]
				[/and]
				[/filter_location]
			[/filter]
			[filter_location]
				[and]
					terrain=*^V*
					radius=1
					[filter_owner]
					[enemy_of]
					side=$side_number
					[/enemy_of]
					[/filter_owner]
					[and]
					[filter]
					[/filter]
					[/and]
					[and]
					[filter]
					side=$side_number
					[/filter]
					radius=4
					[/and]
				[/and]
					[not]
					[filter]
					[/filter]
					[/not]
					[not]
					terrain=W*,S*
					[/not]
			[/filter_location]
		unique_goals=yes
		ignore_enemy_at_goal=yes
		ignore_units=yes
		ca_score=210004
 [/micro_ai]
  [micro_ai]
            side=$side_number
            ai_type=goto
            action=add
            ca_id=ce_goto_enemy_king_in_ship_$side_number   ## attack enemy king in transport ship in range
            [filter]
				[not]
				canrecruit=yes
				[/not]
               ability=ce_warship  ## warships
				[filter_location]
					[filter]
					canrecruit=yes
					[filter_side]
					[enemy_of]
					side=$side_number
					[/enemy_of]
					[/filter_side]
					[/filter]
					radius=6
				[/filter_location]
			[/filter]
			[filter_location]
				[and]
				radius=1
					[filter]
					canrecruit=yes
					[filter_side]
					[enemy_of]
					side=$side_number
					[/enemy_of]
					[/filter_side]
					[/filter]
					[and]
					[filter]
					ability=ce_warship
					side=$side_number
					[/filter]
					radius=6
					[/and]
				[/and]
					[not]
					[filter]
					[/filter]
					[/not]
				[and]
					terrain=W*,W*^*
				[/and]
			[/filter_location]
		unique_goals=yes
		ignore_enemy_at_goal=yes
		ignore_units=no
		ca_score=210011
 [/micro_ai]
 ##
   [micro_ai]
            side=$side_number
            ai_type=goto
            action=add
            ca_id=ce_goto_enemy_warships_$side_number   ## attack enemy warships in range
            [filter]
				[not]
				canrecruit=yes
				[/not]
               ability=ce_warship  ## warships
				[filter_location]
					[filter]
					ability=ce_warship
					[filter_side]
					[enemy_of]
					side=$side_number
					[/enemy_of]
					[/filter_side]
					[/filter]
					radius=6
				[/filter_location]
			[/filter]
			[filter_location]
				[and]
				radius=1
					[filter]
					ability=ce_warship
					[filter_side]
					[enemy_of]
					side=$side_number
					[/enemy_of]
					[/filter_side]
					[/filter]
					[and]
					[filter]
					ability=ce_warship
					side=$side_number
					[/filter]
					radius=6
					[/and]
				[/and]
					[not]
					[filter]
					[/filter]
					[/not]
				[and]
					terrain=W*,W*^*
				[/and]
			[/filter_location]
		unique_goals=yes
		ignore_enemy_at_goal=yes
		ignore_units=no
		ca_score=210010
 [/micro_ai]
 [/event]
#enddef
